# WebLingo ‚Äî MVP (Cloudflare + Supabase) üó∫Ô∏è

A production‚Äëready **MVP** for static‚Äëpage website translation built around a **deterministic edit manifest**, **Cloudflare Workers/Queues/R2/KV**, and **Supabase/Postgres** as the source of truth. The design is **TDD‚Äëfirst**, keeps **token cost** low, and is **reverse‚Äëproxy ready** for dynamic pages later.

> **Hot path (serving):** KV ‚Üí R2 (DB‚Äëfree).  
> **Pipeline:** Crawl/Render ‚Üí Extract ‚Üí Translate (precedence) ‚Üí **Build manifest** ‚Üí Apply ‚Üí Publish ‚Üí Serve.

> Automation note: Codex/agents must start with `AGENTS.md` for workflow & contracts before following this README.

---

## Quickstart (local dev)

**Prereqs**: Node 24 (repo pins `24.11.1` via `.nvmrc` + `package.json#volta`, `engines.node >= 24`), _Corepack-managed_ pnpm 10 (`packageManager` sets `pnpm@10.22.0`; run `corepack enable`), Docker, Supabase CLI (`brew install supabase`), Wrangler (`npm i -g wrangler`).

```bash
# 1) Install
corepack pnpm install

# 2) Start local Postgres + Studio (in another terminal keep it running)
supabase start

# 3) Apply migrations (will be added in /infra/supabase/migrations)
corepack pnpm db:migrate

# 4) Configure Wrangler preview resources (KV, R2, Queues)
#    -> see /infra/wrangler.examples/*.toml for templates

# 5) Put secrets (for Workers)
wrangler secret put SUPABASE_URL
wrangler secret put SUPABASE_PUBLISHABLE_KEY
wrangler secret put SUPABASE_SECRET_KEY
wrangler secret put OPENAI_API_KEY
wrangler secret put WEBHOOK_SECRET

# 6) Run checks (lint + type + coverage tests)
corepack pnpm check

# 7) Run serve worker locally (DB‚Äëfree hot path)
corepack pnpm dev:serve  # wrapper for wrangler dev in workers/serve-worker
```

Wrangler dev does **not** read the root `.env`. Before running `dev:serve`, `dev:webhooks`, or any other worker locally, create a `.dev.vars` file inside that worker‚Äôs directory and copy the Supabase values generated by `supabase start` (see `.env`). Example:

```bash
cat > workers/serve-worker/.dev.vars <<'EOF'
SUPABASE_URL=http://127.0.0.1:54321
SUPABASE_PUBLISHABLE_KEY=sb_publishable_XXXXXXXXXX
SUPABASE_SECRET_KEY=sb_secret_XXXXXXXXXX
ENV=dev
EOF
```

Repeat for `workers/webhooks-worker/.dev.vars` so the onboarding API can reach Supabase. Without these files Wrangler will throw errors such as ‚ÄúSupabase URL is required.‚Äù

**After each milestone**, see the scripts in `package.json` (e.g., `segmenter:cli`, `translator:cli`, `manifest:apply`, `e2e:mini`).

### Context inventory (CAM v2 prep)

- Milestone **M11 ‚Äî Context-Aware Manifest (CAM v2)** introduces Site/Page/Group context capture. Run the migrations in `infra/supabase/migrations` that add `sites.context_profile`, `page_versions.meta_context`, and `segment_groups`, then confirm `workers/extract-worker` stores those rows before enabling CAM tests.
- Populate Site Profiles via onboarding/API or seeds so translate worker prompts can include brand voice + register. See `docs/WebLingo_CAMv2_Context_Aware_Manifest_Report.md` for the phased plan tracked in `docs/TASKS_CHECKLIST.md`.

---

## Repository layout

```
weblingo/
  packages/
    segmenter/           # ICU + per-language patches, placeholders
    translator/          # MT providers + precedence engine
    manifest/            # manifest builder & applier (pure)
    db/                  # Supabase REST client + repositories (fetch-based)
    seo/                 # canonical/hreflang/sitemaps
    common/              # shared types, error helpers, checksums
  workers/
    crawl-worker/
    extract-worker/
    translate-worker/
    render-worker/
    publish-worker/
    serve-worker/
    webhooks-worker/
    digest-worker/
  infra/
    supabase/migrations/ # SQL files
    wrangler.examples/   # example tomls for workers + queues + buckets
  fixtures/
    site/                # tiny 3-page static site used for E2E
    html/                # raw snapshots for tests
  tests/
    e2e/                 # Playwright scripts
  package.json
  pnpm-workspace.yaml
```

---

## Scripts (DX)

Key scripts (run via `corepack pnpm <script>`):

- `build` ‚Äî build every package/worker with tsup.
- `test` ‚Äî Vitest unit suite with coverage (also part of `check`).
- `lint` / `type` / `format` ‚Äî ESLint, `tsc --noEmit`, and Prettier checks.
- `check` ‚Äî runs `lint`, `type`, and `test` in sequence (mirrors CI).
- `db:migrate` ‚Äî applies SQL in `infra/supabase/migrations` via `scripts/db-migrate.ts`.
- `seed:tm` ‚Äî upserts sample translation memory rows into the local Supabase instance (`scripts/seed-segment-targets.ts`).
- `demo:translator` ‚Äî runs segmenter + translator CLI (with Supabase persistence) via `scripts/run-translator-demo.ts` and verifies there is at least one TM hit.
- `e2e:mini` ‚Äî placeholder Playwright spec under `tests/e2e`.
- `e2e:supabase` ‚Äî spins up an isolated Supabase snapshot and runs the supabase-backed pipeline specs (`tests/e2e/pipeline.supabase.test.ts`). See `docs/E2E_SCENARIOS.md` for the scenario matrix.
- `segmenter:cli` ‚Äî run the segmenter against an HTML snapshot (`corepack pnpm segmenter:cli fixtures/html/about.html`).
- Worker helpers:
  - `dev:<worker>` (`crawl`, `extract`, `translate`, `render`, `publish`, `serve`, `webhooks`) ‚Üí `wrangler dev` inside that worker.
  - `deploy:<worker>` ‚Üí `wrangler deploy` for that worker (provide real bindings/secrets first).
  - `wrangler` ‚Äî pass-through `corepack pnpm exec wrangler` for ad-hoc commands.
- `blocks:list` ‚Äî list content blocks + members for a site (`SUPABASE_URL` + `SUPABASE_SECRET_KEY` required): `corepack pnpm blocks:list <siteId>`.

> Ports: `corepack pnpm dev:serve` binds to `http://127.0.0.1:8787`. Run `corepack pnpm dev:webhooks -- --port 8788` in another terminal so the onboarding API listens on `http://127.0.0.1:8788`. Adjust the examples below if you choose different ports.
> Use **pnpm workspaces** for fast builds and isolated packages.

## Test suites

| Scope                           | Command(s)                                                                                                                  | Notes                                                                                                                                                                                                                                                                                                                                                   |
| ------------------------------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Unit + package coverage         | `corepack pnpm test`                                                                                                        | Runs the Vitest suite with coverage (part of `pnpm check`).                                                                                                                                                                                                                                                                                             |
| Worker / package focused        | `corepack pnpm vitest --run workers/<worker>/src/index.test.ts`                                                             | Target a single worker or package when iterating (e.g., publish worker, translator).                                                                                                                                                                                                                                                                    |
| Serve worker HTTP + sitemap e2e | `corepack pnpm vitest --run tests/e2e/pipeline.serve-worker.test.ts`                                                        | Uses Miniflare doubles (Memory KV/R2 + Supabase stub) to exercise canonical/hreflang output, sitemap sharding, and the 307 source fallback without a live database.                                                                                                                                                                                     |
| Supabase snapshot scenarios     | `corepack pnpm e2e:supabase`, `corepack pnpm e2e:supabase:<scenario>`                                                       | Spins up an isolated Supabase branch via `supabase:run`, exports `WEBLINGO_E2E_SUPABASE=1`, then executes `tests/e2e/pipeline.supabase.test.ts`. Scenario tags include `glossary`, `tenants`, `overrides`, `slugs`, `retry`, `rollback`, `onboarding`, and `rerun`. Pass extra Vitest flags with `-- --testNamePattern "...` if you need a one-off run. |
| Pipeline fixtures CLI           | Local: `corepack pnpm pipeline:fixtures` / `corepack pnpm pipeline:fixtures:isolated`; CI: `corepack pnpm e2e:supabase:cli` | Exercises the CLI end-to-end using the demo site. The `:isolated` flavor wraps the run in `supabase:run` so migrations/seeds execute in a throwaway branch, and the `e2e:supabase:cli` spec proves the summary + Supabase failure path.                                                                                                                 |
| Stubbed pipeline mini-suite     | `corepack pnpm e2e:mini`                                                                                                    | Lightweight smoke spec that operates purely on fixtures without Supabase. Useful for CI spot checks.                                                                                                                                                                                                                                                    |

---

### Admin & demo feature flags

- Plan defaults + typed flag schema live in `packages/common/src/feature-flags.ts`; overrides are stored per account in `accounts.feature_flags` and merged over the plan bundle.
- `scripts/seed-plan-fixtures.ts` seeds stable accounts: **admin** (all flags enabled) and **demo** (read-only: `demo_mode=true`, edits/pipeline/creation disabled, `max_sites=1`, `max_locales` capped to the seeded locales).
- Webhooks/dashboard APIs enforce flags server-side; disallowed actions return `403` with `details.code` such as `demo_read_only`, `site_create_disabled`, `slug_edit_disabled`, or `crawl_trigger_disabled`. Frontends can keep actions enabled and surface the server response.

---

### Try-it-now previews & digests

- **Previews:** `POST /api/previews` (webhooks-worker) accepts `sourceUrl`, `sourceLang`, and `targetLang` when authorized via JWT or `x-preview-token` (`TRY_NOW_TOKEN`). The worker snapshots, translates, and stores HTML under `previews/{previewId}/index.html` with TTL (`TRY_NOW_PREVIEW_TTL_SECONDS`), fetch timeout (`TRY_NOW_FETCH_TIMEOUT_MS`), and a streaming body cap (`TRY_NOW_FETCH_MAX_BYTES`, default **1MB**) to block oversized/SSRF payloads. Status lives at `GET /api/previews/:id`; the serve worker renders at `/_preview/{previewId}` with CSP + `noindex`.
- **Digests:** `PUT /api/digests/subscription` upserts per-account email/frequency (`daily|weekly|off`). The `digest-worker` cron aggregates recent deployments per account and delivers summaries via `DIGEST_DELIVERY_MODE=log|webhook` (`DIGEST_WEBHOOK_URL` + optional `DIGEST_WEBHOOK_TOKEN`).

## Environment & bindings

Each worker has a `wrangler.toml`. Example (`workers/serve-worker/wrangler.toml`):

```toml
name = "weblingo-serve"
main = "dist/index.js"
compatibility_date = "2024-10-01"

[[r2_buckets]]
binding = "R2"
bucket_name = "weblingo-artifacts"
preview_bucket_name = "weblingo-artifacts-preview"

[[kv_namespaces]]
binding = "KV"
id = "xxx"
preview_id = "yyy"

[vars]
ENV = "dev"
```

### Serve routing configuration

Route maps now live in Supabase (`site_configs` + `site_domains`). Start the **webhooks worker** with `corepack pnpm dev:webhooks -- --port 8788` so `/api/sites` is available at `http://127.0.0.1:8788`; run the **serve worker** with `corepack pnpm dev:serve` on `http://127.0.0.1:8787` to load those configs automatically, so there‚Äôs no `SITE_ROUTES_JSON` env to maintain. If you pick other ports, update the following examples accordingly.

```bash
# Create a site + locales (pattern must contain {lang}); change the port if dev:webhooks runs elsewhere.
# Requires a valid JWT signed with WEBHOOK_SECRET (use scripts/sign-jwt.ts if available, or a jwt.io token).
# For dev, you can generate a token locally or disable auth temporarily if needed (not recommended).
curl -X POST http://127.0.0.1:8788/api/sites \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <YOUR_JWT_TOKEN>" \
  -d '{
        "sourceUrl": "https://www.example.com",
        "sourceLang": "en",
        "targetLangs": ["fr","ja"],
        "subdomainPattern": "{lang}.example.com"
      }'
```

The response lists the generated domain verification tokens. Add a TXT record (e.g. `weblingo-verification=...`) to your DNS, then verify:

```bash
# Verify a domain (port must match the dev:webhooks instance)
# This performs a real DNS TXT lookup.
curl -X POST \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <YOUR_JWT_TOKEN>" \
  http://127.0.0.1:8788/api/sites/<SITE_ID>/domains/fr.example.com/verify
```

Need to update locales later? `PATCH /api/sites/:id` with a new `targetLangs` array and/or `subdomainPattern`. A `POST /api/sites/:id/crawl` call replays the crawl ‚Üí extract pipeline via the crawl queue, so onboarding can run entirely from the API.

- Optional consistency flag: set `CONSISTENCY_BLOCKS_ENABLED=true` on **extract** and **translate** workers to enable block detection/enforcement (nav/footer Global-Exact). Leave unset to pause heuristics.

> ‚ö†Ô∏è Reminder: create `.dev.vars` files in both `workers/serve-worker` and `workers/webhooks-worker` with `SUPABASE_URL`, `SUPABASE_PUBLISHABLE_KEY`, and `SUPABASE_SECRET_KEY` (copy from `.env`). Wrangler doesn‚Äôt load root env files, so missing entries surface as `Supabase URL is required` errors when you hit `wrangler dev`.

`corepack pnpm pipeline:fixtures` persists the derived route config + domain entries automatically, so local/manual runs keep reading from Supabase just like production.

### Environment variables by worker

**Global/common**

- `SUPABASE_URL`
- `SUPABASE_PUBLISHABLE_KEY`
- `SUPABASE_SECRET_KEY` (or service role key)
- `WEBHOOK_SECRET`
- `OPENAI_API_KEY` (optional; deterministic provider used if unset)

**serve-worker**

- Bindings: `R2`, `KV`
- Vars: `CACHE_TTL_SECONDS?` (default 60), `CACHE_ROUTES_TTL_SECONDS?` (default 300), `ENV?`

**crawl-worker**

- Bindings: `KV`, `EXTRACT_QUEUE`
- Vars: `CRAWL_TRIGGER_TOKEN`, `CRAWL_MAX_DEPTH?`, `CRAWL_MAX_PAGES?`, `CRAWL_IDEM_TTL_SECONDS?`, `CRAWL_USER_AGENT?`

**extract-worker**

- Bindings: `R2`, `KV`, `TRANSLATE_QUEUE`
- Vars: `EXTRACT_IDEM_TTL_SECONDS?`, `EXTRACT_BROWSER_TIMEOUT_MS?`, `EXTRACT_WAIT_UNTIL?`, `EXTRACT_WAIT_FOR_SELECTOR?`, `CONSISTENCY_BLOCKS_ENABLED?`

**translate-worker**

- Bindings: `KV`, `RENDER_QUEUE`
- Vars: `TRANSLATE_IDEM_TTL_SECONDS?`, `OPENAI_API_KEY` (optional), `CONSISTENCY_BLOCKS_ENABLED?`

**render-worker**

- Bindings: `R2`, `KV`, `PUBLISH_QUEUE`
- Vars: `RENDER_IDEM_TTL_SECONDS?`, `RENDER_ROUTE_CACHE_TTL_SECONDS?`

**publish-worker**

- Bindings: `R2`, `KV`
- Vars: `PUBLISH_IDEM_TTL_SECONDS?`

**webhooks-worker**

- Bindings: queues (at least `CRAWL_QUEUE`)
- Vars: `WEBHOOK_SECRET`, `TRY_NOW_TOKEN`, `TRY_NOW_PREVIEW_TTL_SECONDS?`, `TRY_NOW_FETCH_MAX_BYTES?`, `SUPABASE_URL`, `SUPABASE_SECRET_KEY`

**digest-worker**

- Vars: `DIGEST_TRIGGER_TOKEN`, `DIGEST_DELIVERY_MODE` (`log` or `webhook`), `DIGEST_WEBHOOK_URL` (if webhook mode), `DIGEST_WEBHOOK_TOKEN?`, `ENV?`

For local dev convenience, you can reuse the root `.dev.vars` file by symlinking or copying it into each worker folder (Wrangler reads `.dev.vars` from the worker directory). Example:

```bash
for w in workers/*-worker; do
  ln -sf ../../.dev.vars "$w/.dev.vars" || cp .dev.vars "$w/.dev.vars"
done
```

Adjust per worker if you prefer to trim secrets (recommended for prod).

### Setting secrets (dev vs prod)

- **Local dev (`wrangler dev`)**: Wrangler reads `.dev.vars` in each worker directory. Populate these with the Supabase keys from `supabase start` (or symlink from the root `.dev.vars` as above). Running `wrangler secret put` without `--remote/--env` will not affect local Miniflare.
- **Production deploy**: Set secrets per worker in your Cloudflare account with `wrangler secret put` from inside each worker directory (or use `--name <worker>`). Example for translate-worker:
  ```bash
  wrangler secret put SUPABASE_URL
  wrangler secret put SUPABASE_PUBLISHABLE_KEY
  wrangler secret put SUPABASE_SECRET_KEY
  wrangler secret put OPENAI_API_KEY
  ```
  Repeat for other workers‚Äô secrets (e.g., `WEBHOOK_SECRET`, `TRY_NOW_TOKEN`, `DIGEST_*`, `CRAWL_TRIGGER_TOKEN`). Use `--env dev` if you maintain separate dev/stage environments.

### Dashboard/frontend API base

- Local dev: point the dashboard/frontend to the webhooks worker dev endpoint, e.g. `NEXT_PUBLIC_WEBHOOKS_API_BASE=http://127.0.0.1:8788/api` (adjust port if you run `dev:webhooks` on another port).
- Stage/prod: use your deployed webhooks domain with `/api`, e.g. `https://webhooks.example.com/api`.
- The dashboard only needs the webhooks worker; serve/pipeline workers remain backend-only.

### Route config anatomy (serve/render/publish)

The site route map lives in Supabase `site_configs` and is consumed by render/publish/serve workers. Key fields:

- `source_origin`: Base URL of the untranslated site (e.g., `https://example.com`) used by crawl/extract to fetch HTML.
- `locales[]`: Per-locale deployment targets:
  - `lang`: BCP-47 tag.
  - `origin`: Base URL/host where translated pages are served (e.g., `https://fr.example.com` or `https://example.com` for shared hosts).
  - `route_prefix` (optional): Path prefix under the locale origin (e.g., `/fr`), so `/about` renders at `https://example.com/fr/about` while `/team` renders at `https://example.com/fr/team`. Empty/omitted means the locale uses root paths on that origin.
- `source_lang`: Source language for hreflang/canonical generation.

Example:

```json
{
  "siteId": "site-1",
  "sourceLang": "en",
  "sourceOrigin": "https://example.com",
  "locales": [
    { "lang": "fr", "origin": "https://example.com", "routePrefix": "/fr" },
    { "lang": "es", "origin": "https://es.example.com", "routePrefix": "" }
  ]
}
```

Queues are defined similarly in worker tomls:

```toml
[[queues.producers]]
queue = "weblingo-crawl"

[[queues.consumers]]
queue = "weblingo-crawl"
max_batch_size = 10
max_batch_timeout = 2
```

## Production deploy (Cloudflare + Supabase)

```bash
# Resources
wrangler kv namespace create KV
wrangler r2 bucket create weblingo-artifacts
wrangler queues create weblingo-{crawl,extract,translate,render,publish}

# Secrets
wrangler secret put SUPABASE_URL
wrangler secret put SUPABASE_PUBLISHABLE_KEY
wrangler secret put SUPABASE_SECRET_KEY
wrangler secret put OPENAI_API_KEY
wrangler secret put WEBHOOK_SECRET

# Deploy workers
wrangler deploy workers/serve-worker
wrangler deploy workers/crawl-worker
wrangler deploy workers/extract-worker
wrangler deploy workers/translate-worker
wrangler deploy workers/render-worker
wrangler deploy workers/publish-worker
wrangler deploy workers/webhooks-worker
wrangler deploy workers/digest-worker

# Apply migrations to the target Supabase project
corepack pnpm db:migrate
```

Use the webhooks API to onboard sites (`POST /api/sites` with a JWT signed by `WEBHOOK_SECRET`), add DNS TXT records for each generated verification token, and call `/api/sites/:id/domains/<domain>/verify` to activate locales before serving traffic.

---

## What to build (short)

- **Segmenter**: HTML ‚Üí blocks ‚Üí placeholders ‚Üí ICU segmentation ‚Üí `seg_id`, `context_hash`, `dom_locator`.
- **Translator**: precedence **overrides ‚Üí glossary ‚Üí TM ‚Üí MT**; strict placeholder validation; batch MT.
- **Manifest**: schema (selector + anchors + `expected_source` + checksum). Builder & **idempotent** applier.
- **Workers/Queues**: `crawl` ‚Üí `extract` ‚Üí `translate` ‚Üí `render` ‚Üí `publish`. All idempotent (KV).
- **Serve worker**: KV ‚Üí R2 mapping; cache; rollback via `prev.html`.
- **SEO**: canonical + hreflang with localized slugs/meta tags; per‚Äëlocale sitemaps; link rewriting to locale hosts.

> Full details live in **docs/MVP_TDD_Implementation_Guide.md**.

---

## Local E2E

```bash
# Ensure Supabase is running (generates `.env` with service keys)
supabase start

# Seed sample site + locales in Supabase
corepack pnpm db:seed

# Kick pipeline on fixtures (without CF Browser Rendering)
corepack pnpm pipeline:fixtures

# Serve locally (start serve + onboarding API in separate terminals)
corepack pnpm dev:serve                     # translated HTML on 127.0.0.1:8787
corepack pnpm dev:webhooks -- --port 8788   # onboarding API on 127.0.0.1:8788
open http://127.0.0.1:8787/ja/about
```

If Wrangler can‚Äôt reach Supabase, double-check the `.dev.vars` files in each worker directory contain the `SUPABASE_*` values from `.env`.

The pipeline CLI uses Miniflare to emulate KV/R2 locally, writes artifacts to `.tmp/pipeline/artifacts`, and prints the KV deployment pointers so you can open the rendered HTML directly from disk.

### Isolated Supabase branches (tests/CI)

Use the `supabase:run` helper to spin up a disposable Supabase CLI branch, run a command, then tear everything down so fixtures/tests never pollute your default database:

```bash
# Spins up supabase/.branches/test-xxxx, runs pipeline:fixtures, stops, removes branch dir
corepack pnpm pipeline:fixtures:isolated

# Reuse a specific branch (kept after the run)
corepack pnpm supabase:run -- --branch ci-$GITHUB_RUN_ID --keep-branch -- corepack pnpm test
```

CI example:

```yaml
- name: Run pipeline fixtures in isolated Supabase
  run: |
    corepack pnpm install
    corepack pnpm supabase:run -- --branch "ci-${{ github.run_id }}" -- corepack pnpm pipeline:fixtures
```

The script simply wraps `supabase start/stop` while setting `SUPABASE_DEV_BRANCH`; see `scripts/supabase-branch-run.ts` for details.

Need fuller coverage than the stub harness? Run the Supabase snapshot suite:

```bash
corepack pnpm e2e:supabase
```

It provisions a disposable Supabase branch, replays migrations/seeds, then executes `tests/e2e/pipeline.supabase.test.ts`. Refer to `docs/E2E_SCENARIOS.md` for the exact cases (glossary precedence, duplicate segment dedupe, multi-tenant isolation, and upcoming TODOs). You can target individual scenarios too:

```bash
# Only run the glossary/dedup case
corepack pnpm e2e:supabase:glossary

# Only run the dual-tenant isolation case
corepack pnpm e2e:supabase:tenants

# Contextual overrides / slug paths / retry failpoints
corepack pnpm e2e:supabase:overrides
corepack pnpm e2e:supabase:slugs
corepack pnpm e2e:supabase:retry
```

### Pipeline fixtures vs Supabase snapshots

| Command                                    | Scope                                                                                                                                    | Isolation                                                 |
| ------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| `corepack pnpm pipeline:fixtures`          | Exercises the CLI against the seeded demo site using Miniflare doubles (no Supabase spin-up).                                            | Uses whatever Supabase instance `.env` points at.         |
| `corepack pnpm pipeline:fixtures:isolated` | Same pipeline flow, but wrapped in `supabase:run` so migrations+seeds happen in a throwaway branch before invoking the CLI.              | Spins up a temporary Supabase branch, then tears it down. |
| `corepack pnpm e2e:supabase`               | Runs Vitest specs that orchestrate targeted scenarios (glossary precedence, dual tenant isolation) against real Supabase REST endpoints. | Spin up/tear down per run via `supabase:run`.             |

Use the fixtures CLI when you want confidence that the entire worker chain still produces deterministic artifacts. Reach for the Supabase suite when you need to validate DB constraints, multi-tenant safety, or regression-specific flows. Both approaches share the same isolation helper so they can run locally or in CI without leaking state.

---

## Deployment (Cloudflare + Supabase)

1. **Create resources**: R2 bucket, KV namespace, Queues (crawl/extract/translate/render/publish).
2. **Secrets**: `SUPABASE_URL`, `SUPABASE_PUBLISHABLE_KEY`, `SUPABASE_SECRET_KEY`, `OPENAI_API_KEY`, `WEBHOOK_SECRET`.
3. **Deploy workers**:
   ```bash
   wrangler deploy workers/serve-worker
   wrangler deploy workers/crawl-worker
   wrangler deploy workers/extract-worker
   wrangler deploy workers/translate-worker
   wrangler deploy workers/render-worker
   wrangler deploy workers/publish-worker
   wrangler deploy workers/webhooks-worker
   ```
4. **Cron**: add a daily cron that enqueues crawl per site.
5. **Custom domains**: map `ja.example.com` to `serve-worker` route.
6. **Smoke**: curl a translated route; verify cache headers and canonical/hreflang.

---

## Development Principles & Policy

- **YAGNI**, **DRY**, **SOLID**, **Offensive w/ defensive boundaries**, **small cohesive modules**, **tests with code**.
- **Abstraction Policy**: only add an abstraction for a clear, immediate benefit; avoid speculative indirection.

---

## Using the checklist

Open **docs/TASKS_CHECKLIST.md**, work milestone by milestone. Do not proceed until **DoD** is complete. Run the per‚Äëmilestone commands from the guide after each step.  
Post‚ÄëMVP milestones (M7+) reference `docs/POST_MVP_ROADMAP.md`; read the cited sections there before starting any roadmap tasks (e.g., the self‚Äëservice onboarding API in ¬ß¬ß1.1‚Äì1.2, 8.3 will live inside the existing Cloudflare workers so the Next.js/Stripe frontend can call into it).

---

## License

Proprietary ‚Äî internal project bootstrap.
